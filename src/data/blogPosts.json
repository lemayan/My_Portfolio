[
  {
    "id": 1,
    "title": "Why I Switched to Next.js 14 and Server Actions for My Latest Project",
    "excerpt": "I used to rely heavily on separate backend APIs. Now, with Next.js 14 and Server Actions, I've completely rethought my approach to full-stack development.",
    "content": "When I first started building full-stack applications, the standard practice was clear: build a React frontend, spin up a Node.js or Python backend, and connect them via REST or GraphQL. That was my workflow for years. But recently, I decided to take the plunge into Next.js 14 and its highly talked-about feature: Server Actions. \n\nThe moment I realized I could securely mutate data directly from my React components without writing endless API routes, my mind was blown. I found myself deleting dozens of boilerplate fetch calls and API endpoint files. The reduction in context switching alone has made me significantly more productive. While the mental model shift took a weekend to click, I now feel like I'm writing the most cohesive code of my career. The performance gains from Server Components combined with the simplicity of Server Actions have convinced me that this is the definitive future of React development.",
    "author": "Dennis Leleina",
    "date": "2026-02-25",
    "readTime": "5 min read",
    "category": "Web Development",
    "tags": [
      "Next.js",
      "React",
      "Server Actions",
      "Performance"
    ],
    "image": "/assets/projects/blog-1.png",
    "featured": true
  },
  {
    "id": 2,
    "title": "How I Use AI Tools to 10x My Coding Speed",
    "excerpt": "My honest thoughts on integrating GitHub Copilot and ChatGPT into my daily workflow, and how it shifted my focus from syntax to architecture.",
    "content": "I remember the skepticism I had when AI coding assistants first hit the mainstream. I thought, 'There's no way a machine can understand the complex business logic I need to write.' Fast forward to today, and I honestly can't imagine working without GitHub Copilot and conversational LLMs by my side.\n\nMy workflow has drastically changed. Instead of spending 20 minutes digging through StackOverflow or wrestling with regex, I describe my intent and let the AI draft the boilerplate. This hasn't made me lazy; rather, it has elevated my role from a 'code typist' to a system architect. I now spend the majority of my time thinking about edge cases, app security, and optimal database schemas. The AI handles the mundane syntax. However, I've learned the hard way that you must always review the generated code critically. AI is an incredibly powerful co-pilot, but at the end of the day, I'm the one flying the plane.",
    "author": "Dennis Leleina",
    "date": "2026-02-18",
    "readTime": "6 min read",
    "category": "Artificial Intelligence",
    "tags": [
      "AI",
      "Copilot",
      "LLMs",
      "Productivity"
    ],
    "image": "/assets/projects/blog-2.png",
    "featured": true
  },
  {
    "id": 3,
    "title": "My Journey Building a dApp on the Solana Blockchain",
    "excerpt": "Moving from traditional Web2 to Web3 was a steep learning curve. Here's my experience building my first decentralized application on Solana.",
    "content": "I've been building traditional web applications for a while, but the decentralized web always felt like a shiny, intimidating black box. I decided it was time to change that and dive headfirst into Web3 by building a decentralized application (dApp) on Solana. \n\nLearning Rust for Solana smart contracts (programs) was a humbling experience. I had to unlearn a lot of garbage-collection habits and deeply understand memory management and ownership. But when I finally deployed my first program to the Devnet and saw my React frontend interact with the blockchain in sub-second times with fraction-of-a-penny fees, I had a massive 'Aha!' moment. The tooling in the Solana ecosystem has matured incredibly fast. I used Anchor, which felt surprisingly similar to using a framework like Express or Django but for the blockchain. Building this dApp showed me the true potential of cryptographic consensus over traditional centralized databases.",
    "author": "Dennis Leleina",
    "date": "2026-02-10",
    "readTime": "8 min read",
    "category": "Web3",
    "tags": [
      "Blockchain",
      "Solana",
      "Web3",
      "Smart Contracts"
    ],
    "image": "/assets/projects/blog-3.png",
    "featured": false
  },
  {
    "id": 4,
    "title": "Why I Believe Edge Computing is the Future of Web Deployment",
    "excerpt": "Saying goodbye to traditional centralized servers. How deploying to the edge drastically improved my applications' latency and reliability.",
    "content": "For the longest time, my deployment strategy was simple: spin up a server in a specific region (usually US-East), deploy my Node.js app, and hope my global users didn't complain too much about latency. Then, I discovered Edge Computing.\n\nWhen I first migrated one of my side projects to an Edge runtime using Vercel and Cloudflare, the results were staggering. My server logic was suddenly being executed physically closer to my users, whether they were in Tokyo, London, or Nairobi. The time-to-first-byte (TTFB) dropped to double-digit milliseconds universally. Writing code for the Edge did require some adjustmentsâ€”I couldn't rely on certain Node.js core modules and had to be mindful of cold starts and execution time limits. But the tradeoff is absolute magic. I now architect my apps 'Edge-first', relying on distributed databases and edge-caching to deliver instant experiences worldwide.",
    "author": "Dennis Leleina",
    "date": "2026-01-28",
    "readTime": "7 min read",
    "category": "Cloud Computing",
    "tags": [
      "Edge",
      "Vercel",
      "Cloudflare",
      "Performance"
    ],
    "image": "/assets/projects/blog-4.png",
    "featured": false
  },
  {
    "id": 5,
    "title": "How I Design Premium UIs Faster with AI Generators",
    "excerpt": "Generative UI tools are changing frontend development. Here is how I use tools like v0 to prototype and build stunning interfaces in record time.",
    "content": "If you had told me a year ago that I could type 'Generate a dark-mode fintech dashboard with glowing charts' and receive production-ready React and Tailwind code seconds later, I wouldn't have believed you. But that's exactly what I'm doing today with generative UI tools like Vercel's v0.\n\nI used to spend hours tweaking CSS flexbox layouts and finding the perfect hex codes. Now, my design process starts with a prompt. I generate the foundational structure of a component, paste the React code into my project, and then I do what I do best: refine it. I tweak the animations, hook up the state management, and ensure it matches my precise brand identity. These AI tools haven't replaced my frontend skills; they've given me an impossibly fast starting line. I can now deliver premium, highly polished web experiences in a fraction of the time it used to take me.",
    "author": "Dennis Leleina",
    "date": "2026-01-15",
    "readTime": "6 min read",
    "category": "Design & UI",
    "tags": [
      "AI Generation",
      "Tailwind CSS",
      "UI/UX",
      "Frontend"
    ],
    "image": "/assets/projects/blog-5.png",
    "featured": false
  },
  {
    "id": 6,
    "title": "My Experience Exploring WebAssembly for High-Performance Browser Apps",
    "excerpt": "Taking browser performance to native levels. Why I started experimenting with WebAssembly and Rust for computationally heavy web features.",
    "content": "JavaScript is incredibly versatile, but it has its limits when it comes to intense, CPU-bound tasks in the browser. Recently, I hit a performance wall while building an image processing feature. That's when I decided it was time to get my hands dirty with WebAssembly (Wasm).\n\nI chose to write the performance-critical parts in Rust and compiled them to Wasm. Compiling a completely entirely different language to run alongside JavaScript inside the browser feels somewhat like magic. The interoperability setup took some trial and error, specifically figuring out how to efficiently pass complex data structures between JS and Wasm memory. However, once it clicked, the performance gains were undeniable. Image processing tasks that used to lock up the main thread for several seconds were suddenly resolving in under a second. Getting into WebAssembly has completely expanded my view on what is possible within a web browser.",
    "author": "Dennis Leleina",
    "date": "2026-01-02",
    "readTime": "8 min read",
    "category": "WebAssembly",
    "tags": [
      "Wasm",
      "Rust",
      "Web Development",
      "Performance"
    ],
    "image": "/assets/projects/blog-6.png",
    "featured": false
  }
]